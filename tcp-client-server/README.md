# Сокеты
## Разработка клиент-серверного приложения на основе непосредственного использования сокетов

### 0. Подготовка к работе

Познакомиться с git:

https://git-scm.com/book/ru/v2/Введение-Основы-Git

Завести аккаунт на github.com. Клонировать репозиторий:

https://github.com/v-sukhov/software-development-course.git

Настроить аутентифкацию с использованием SSH-ключа:

https://help.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh

Папка данной серии проектов:

tcp-client-server

При выполнении заданий в подпапках для каждого проекта необходимо создавать папку со своей фамилией (латиницей) и выполнять проект в ней.

### Проект 1: простейшее клиент-серверное приложение

1. Утилита make. Изучить:

https://habr.com/ru/post/211751/

**Важное замечание! При выполнении заданий выполняемые бинарные файлы необходимо именовать с расширением .out, чтобы они подпадали под условия gitignore.**

2. Метриалы по сокетам:

https://rtfm.co.ua/c-sokety-i-primer-modeli-client-server/

https://www.thegeekstuff.com/2011/12/c-socket-programming/

http://artlib.osu.ru/Docs/piter/bookchap/978594723991.html

3. Создаём простейшее клиент-серверное приложение из примера

https://gist.github.com/browny/5211329

4. Задаём серверу порт. По умолчанию должен быть 5000. Если порт не из диапазона 1000 - 64000 - сообщать об ошибке и не запускаться.

5. Добавляем логирование на сервере. Логирование должно быть в виде:
<IP клиента>: <отправляемое сообщение>


### Проект 2: Обслуживание нескольких открытых соединений

1. Блокирующие вызовы. Изучить select:

https://www.opennet.ru/man.shtml?topic=select&category=2&russian=0

2. Модернизировать проект следущим образом: сервер должен раз в 5 секунд каждому клиенту отсылать время (можно одинаковое всем клиентам и
при подключении отправлять клиенту не сразу). Допускается подключение новых клиентов. При отключении клиента сервер должен корректно закрывать
соединение и больше не отправлять этому клиенту ничего. Если клиент оборвал соединение - сервер должен продолжать корректно работать.

Нужно корректно игнорировать сигнал SIGPIPE (сигнал, передаваемый при попытке чтения из закрытого сокета и по-умолчанию приводящий к аварийному завершению работы программы):

	signal(SIGPIPE, SIG_IGN);
	
или использовать send с флагом MSG_NOSIGNAL. См.:

https://stackoverflow.com/questions/108183/how-to-prevent-sigpipes-or-handle-them-properly
		

### Проект 3: мессенджер

1. Ознакомиться с ncurses. Провести эксперименты.

Установка ncurses:

	sudo apt-get install libncurses5-dev libncursesw5-dev

Материалы по ncurses:

https://code-live.ru/post/cpp-ncurses-hello-world

https://code-live.ru/post/terminal-mode-management-ncurses/

https://code-live.ru/post/ncurses-input-output/

*Важно! После printw нужно выполнять refresh()*

2. Создать клиент-серверное приложение Мессенджер. Сервер должен логировать следующие события:
	1. Подключение пользователя
	2. Регистрация пользователя
	3. Отправка пользователем сообщений

Дополнительные задания:

3. Сделать отправку по клавише Enter
4. Включить кириллицу

Для этого необходимо в коде добавить:

	#include <locale.h>
	...
	setlocale(LC_ALL, "");

и при линковке заменить -lnurses на -lncursesw:

	client: client.o
		gcc client.o -lncursesw -o client.out

5. Для ранее зарегистрировавшихся, но переподключившихся пользователей отправлять историю - что они пропустили.
	


	
	
	
	
